import { generateFullSignature, AbiDescription, EventDescription, FunctionDescription, ParameterDescription, EventParameterDescription } from '@zoltu/ethereum-abi-encoder'
import { keccak256 } from '@zoltu/ethereum-crypto'

type Abi = ReadonlyArray<AbiDescription>

export interface CompilerOutput {
	readonly contracts: {
		[globalName: string]: {
			[contractName: string]: {
				readonly abi: Abi
			}
		}
	}
}

export async function generateContractInterfaces(contractsOutput: Readonly<CompilerOutput>): Promise<string> {
	const contractInterfaces: Array<string> = []
	const eventDescriptions: Map<string, string> = new Map<string, string>()
	const eventInterfaces: Array<string> = []
	const eventTypes: Array<string> = []

	const duplicateCounters: Record<string, number> = {}
	for (let globalName in contractsOutput.contracts) {
		for (let contractName in contractsOutput.contracts[globalName]) {
			const contractAbi: Abi = contractsOutput.contracts[globalName][contractName].abi
			if (contractAbi.length == 0) continue
			duplicateCounters[contractName] = (duplicateCounters[contractName] || 0) + 1
			const contractNameSuffix = duplicateCounters[contractName] === 1 ? '' : duplicateCounters[contractName]
			contractInterfaces.push(contractInterfaceTemplate(`${contractName}${contractNameSuffix}`, contractAbi))
			for (let abiEvent of contractAbi.filter(abiEntry => abiEntry.type === 'event').map(abiEntry => <EventDescription>abiEntry).filter(abiEvent => abiEvent.name)) {
				const eventDescription = await eventDescriptionTemplate(abiEvent)
				eventDescriptions.set(eventDescription.substring(1, 65), eventDescription)
				const eventInterface = eventInterfaceTemplate(contractName, abiEvent)
				eventInterfaces.push(eventInterface)
				eventTypes.push(`${contractName}.${abiEvent.name}`)
			}
		}
	}

	return `// THIS FILE IS AUTOMATICALLY GENERATED BY \`generateContractInterfaces.ts\`. DO NOT EDIT BY HAND'

import { EventDescription, DecodedEvent, ParameterDescription, EncodableArray, EncodableTuple, decodeParameters, decodeEvent, decodeMethod } from '@zoltu/ethereum-abi-encoder'
export { EncodableArray, EncodableTuple }

export interface Log {
	readonly topics: ReadonlyArray<bigint>
	readonly data: Uint8Array
}
export interface TransactionReceipt {
	readonly status: boolean
	readonly logs: Iterable<Log>
}

export const eventDescriptions: { [signatureHash: string]: EventDescription & {signature: string} } = {
${Array.of(...eventDescriptions.values()).map(x => `\t${x}`).join(',\n')}
}

${eventInterfaces.join('\n\n')}

export type Event = DecodedEvent${eventTypes.length !== 0 ? ' | ': ''}${eventTypes.join(' | ')}


export interface Dependencies {
	call(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<Uint8Array>
	submitTransaction(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<TransactionReceipt>
}


/**
 * By convention, pure/view methods have a \`_\` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a local version and a remote version (distinguished by the trailing \`_\`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).
 */
export class Contract {
	protected constructor(protected readonly dependencies: Dependencies, public readonly address: bigint) { }

	protected async localCall(methodSignature: string, outputParameterDescriptions: ReadonlyArray<ParameterDescription>, methodParameters: EncodableArray, attachedEth?: bigint): Promise<EncodableTuple> {
		const result = await this.dependencies.call(this.address, methodSignature, methodParameters, attachedEth || 0n)
		if (result.length >= 4 && result[0] === 8 && result[1] === 195 && result[2] === 121 && result[3] === 160) {
			const decodedError = decodeMethod(0x08c379a0, [ { name: 'message', type: 'string' } ], result) as { message: string }
			throw new Error(\`Contract Error: \${decodedError.message}\`)
		}
		return decodeParameters(outputParameterDescriptions, result)
	}

	protected async remoteCall(methodSignature: string, parameters: EncodableArray, errorContext: { transactionName: string }, attachedEth?: bigint): Promise<Array<Event>> {
		const transactionReceipt = await this.dependencies.submitTransaction(this.address, methodSignature, parameters, attachedEth || 0n)
		if (!transactionReceipt.status) throw new Error(\`Remote call of \${errorContext.transactionName} failed: \${JSON.stringify(transactionReceipt)}\`)
		return this.decodeEvents(transactionReceipt.logs)
	}

	private decodeEvents(encodedEvents: Iterable<Log>): Array<Event> {
		const decodedEvents: Array<DecodedEvent> = []
		for (const encodedEvent of encodedEvents) {
			const decodedEvent = this.tryDecodeEvent(encodedEvent)
			if (decodedEvent) decodedEvents.push(decodedEvent)
		}
		return decodedEvents as Array<Event>
	}

	private tryDecodeEvent(encodedEvent: Log): DecodedEvent | null {
		const signatureHash = encodedEvent.topics[0]
		const eventDescription = eventDescriptions[signatureHash.toString(16)]
		if (!eventDescription) return null
		return decodeEvent(eventDescription, encodedEvent.topics, encodedEvent.data)
	}
}

${contractInterfaces.join('\n')}`
}

function contractInterfaceTemplate(contractName: string, contractAbi: Abi) {
	const contractMethods: Array<string> = []

	// FIXME: Add support for Solidity function overloads.  Right now overloaded functions are not supported, only the first one seen will survive addition into the following set.
	const seenCount: Record<string, number> = {}

	const contractFunctions: Array<FunctionDescription> = contractAbi
		.filter(abiEntry => abiEntry.type == 'function')
		.map(abiFunction => <FunctionDescription>abiFunction)

	for (let abiFunction of contractFunctions) {
		seenCount[abiFunction.name] = (seenCount[abiFunction.name] || 0) + 1
		const functionName = (seenCount[abiFunction.name] !== 1) ? `${abiFunction.name}${seenCount[abiFunction.name]}` : abiFunction.name
		if (abiFunction.stateMutability !== 'pure' && abiFunction.stateMutability !== 'view') {
			contractMethods.push(remoteMethodTemplate(functionName, abiFunction, { contractName: contractName}))
		}
		contractMethods.push(localMethodTemplate(functionName, abiFunction, { contractName: contractName}))
	}

	return `
export class ${contractName} extends Contract {
	public constructor(dependencies: Dependencies, address: bigint) {
		super(dependencies, address)
	}

${contractMethods.join('\n\n')}
}
`
}

async function eventDescriptionTemplate(abiEvent: EventDescription): Promise<string> {
	const signature = toSignature(abiEvent.name, abiEvent.inputs)
	const signatureHash = await keccak256.hash(new TextEncoder().encode(signature))
	const eventDescription = {
		type: 'event',
		name: abiEvent.name,
		signature: signature,
		inputs: abiEvent.inputs.map(scrubParameterDescription),
	}
	return `'${signatureHash.toString(16)}': ${JSON.stringify(eventDescription)}`
}

function scrubParameterDescription(parameterDescription: ParameterDescription): ParameterDescription {
	return {
		type: parameterDescription.type,
		name: parameterDescription.name,
		...( 'components' in parameterDescription ? { components: (parameterDescription.components || []).map(scrubParameterDescription) } : {}),
		...('indexed' in parameterDescription ? { indexed: (parameterDescription as EventParameterDescription).indexed } : {})
	}
}

function eventInterfaceTemplate(contractName: string, abiEvent: EventDescription): string {
	return `export namespace ${contractName} {
	export interface ${abiEvent.name} extends DecodedEvent {
		name: '${abiEvent.name}'
		parameters: {
${
	abiEvent.inputs
		.map(parameter => (parameter.indexed && parameter.type === 'string') ? { ...parameter, type: 'bytes32' } : parameter)
		.map(input => `\t\t\t${input.name}: ${toTsTypeString(input, false, { contractName: contractName, functionName: abiEvent.name })}`).join('\n')
}
		}
	}
}`
}

function remoteMethodTemplate(functionName: string, abiFunction: FunctionDescription, errorContext: { contractName: string }) {
	const argNames: string = toArgNameString(abiFunction)
	const params: string = toParamsString(abiFunction, true, errorContext)
	const methodSignature = generateFullSignature(abiFunction)
	const separator = (abiFunction.inputs.length !== 0 && abiFunction.stateMutability === 'payable') ? ', ' : ''
	const attachedEthInputParameter = (abiFunction.stateMutability === 'payable') ? 'attachedEth?: bigint' : ''
	const attachedEthCallParameter = (abiFunction.stateMutability === 'payable') ? ', attachedEth' : ''
	return `	public ${functionName} = async (${params}${separator}${attachedEthInputParameter}): Promise<Array<Event>> => {
		const methodSignature = '${methodSignature}' as const
		const methodParameters = [${argNames}] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: '${abiFunction.name}' }${attachedEthCallParameter})
	}`
}

function localMethodTemplate(functionName: string, abiFunction: FunctionDescription, errorContext: { contractName: string }) {
	const outputs = abiFunction.outputs || []
	const argNames: string = toArgNameString(abiFunction)
	const params: string = toParamsString(abiFunction, true, errorContext)
	const methodSignature = generateFullSignature(abiFunction)
	const separator = (abiFunction.inputs.length !== 0 && (abiFunction.stateMutability === 'payable')) ? ', ' : ''
	const attachedEthInputParameter = (abiFunction.stateMutability === 'payable') ? 'attachedEth?: bigint' : ''
	const attachedEthCallParameter = (abiFunction.stateMutability === 'payable') ? ', attachedEth' : ''
	const returnType: string = toTsReturnTypeString(outputs, { contractName: errorContext.contractName, functionName: abiFunction.name })
	const returnValue: string = (outputs.length === 1)
		? `<${returnType}>result.${outputs[0].name || 'result'}`
		: `<${returnType}>result`
	return `	public ${functionName}_ = async (${params}${separator}${attachedEthInputParameter}): Promise<${returnType}> => {
		const methodSignature = '${methodSignature}' as const
		const methodParameters = [${argNames}] as const
		const outputParameterDescriptions = ${JSON.stringify(abiFunction.outputs)} as const
		${outputs.length !== 0 ? 'const result = ' : ''}await this.localCall(methodSignature, outputParameterDescriptions, methodParameters${attachedEthCallParameter})${outputs.length !== 0 ? `\n\t\treturn ${returnValue}` : ''}
	}`
}

function toTsReturnTypeString(abiParameters: ReadonlyArray<ParameterDescription>, errorContext: { contractName: string, functionName: string }): string {
	if (abiParameters.length === 0) return `void`
	else if (abiParameters.length === 1) return toTsTypeString(abiParameters[0], false, errorContext)
	else if (!abiParameters.every(abiParameter => !!abiParameter.name)) throw new Error(`Function ${errorContext.contractName}.${errorContext.functionName} has multiple return values but not all are named.`)
	else return `{${abiParameters.map(abiParameter => `${abiParameter.name}: ${toTsTypeString(abiParameter, false, errorContext)}`).join(', ')}}`
}

function toTsTypeString(abiParameter: ParameterDescription, readonly: boolean, errorContext: { contractName: string, functionName: string }): string {
	if (/^u?int(\d*)$/.test(abiParameter.type)) {
		return `bigint`
	} else if (/^address$/.test(abiParameter.type)) {
		return 'bigint'
	} else if (/^bool$/.test(abiParameter.type)) {
		return 'boolean'
	} else if (/^bytes\d+$/.test(abiParameter.type)) {
		return `bigint`
	} else if (/^string$/.test(abiParameter.type)) {
		return 'string'
	} else if (/^bytes$/.test(abiParameter.type)) {
		return 'Uint8Array'
	} else if (/^.*?\[\d*\]$/.test(abiParameter.type)) {
		const nestedParameterDescription = Object.assign({}, abiParameter, { type: /^(.*?)\[\d*\]$/.exec(abiParameter.type)![1] })
		return `${readonly ? 'Readonly' : ''}Array<${toTsTypeString(nestedParameterDescription, readonly, errorContext)}>`
	} else if (/^tuple$/.test(abiParameter.type)) {
		return `{ ${abiParameter.components!.map(component => `${readonly ? 'readonly ' : ''}${component.name}: ${toTsTypeString(component, readonly, errorContext)}`).join(', ')} }`
	} else if (/^u?fixed\d+x\d+$/.test(abiParameter.type)) {
		throw new Error(`fixed point parameters are not supported`)
	} else if (/^function$/.test(abiParameter.type)) {
		throw new Error(`function parameters are not supported`)
	} else {
		throw new Error(`Unrecognized parameter type in ${errorContext.contractName}.${errorContext.functionName}: ${JSON.stringify(abiParameter)}`)
	}
}

function toArgNameString(abiFunction: FunctionDescription) {
	return abiFunction.inputs.map(toParamNameString).join(', ')
}

function toParamsString(abiFunction: FunctionDescription, readonly: boolean, errorContext: { contractName: string }) {
	if (abiFunction.inputs.length == 0) return ''
	return abiFunction.inputs.map((abiParameter, i) => `${toParamNameString(abiParameter, i)}: ${toTsTypeString(abiParameter, readonly, { contractName: errorContext.contractName, functionName: abiFunction.name })}`).join(', ')
}

function toParamNameString(abiParameter: ParameterDescription, index: number) {
	if (!abiParameter.name) return `arg${index}`
	else if (abiParameter.name.startsWith('_')) return abiParameter.name.substr(1)
	else return abiParameter.name
}

function toSignature(name: string, params: ReadonlyArray<ParameterDescription>): string {
	const parameters = stringifyParamsForSignature(params).join(',')
	return `${name}(${parameters})`
}

function stringifyParamsForSignature(params: ReadonlyArray<ParameterDescription>): Array<string> {
	return params.map(param => {
		if (param.type === 'tuple') {
			if (!param.components) throw new Error(`Expected components when type is ${param.type}`)
			return `(${stringifyParamsForSignature(param.components).join(',')})`
		} else if (param.type === 'tuple[]') {
			if (!param.components) throw new Error(`Expected components when type is ${param.type}`)
			return `(${stringifyParamsForSignature(param.components).join(',')})[]`
		} else {
			return param.type
		}
	})
}

// https://github.com/microsoft/TypeScript/issues/31535
interface TextEncoder {
	/** Returns "utf-8". */
	readonly encoding: string
	/** Returns the result of running UTF-8's encoder. */
	encode(input?: string): Uint8Array
}
declare var TextEncoder: { prototype: TextEncoder; new(): TextEncoder }
