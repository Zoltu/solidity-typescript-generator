// THIS FILE IS AUTOMATICALLY GENERATED BY `generateContractInterfaces.ts`. DO NOT EDIT BY HAND'

export type Int256<TLargeInteger> = TLargeInteger
export type Int248<TLargeInteger> = TLargeInteger
export type Int240<TLargeInteger> = TLargeInteger
export type Int232<TLargeInteger> = TLargeInteger
export type Int224<TLargeInteger> = TLargeInteger
export type Int216<TLargeInteger> = TLargeInteger
export type Int208<TLargeInteger> = TLargeInteger
export type Int200<TLargeInteger> = TLargeInteger
export type Int192<TLargeInteger> = TLargeInteger
export type Int184<TLargeInteger> = TLargeInteger
export type Int176<TLargeInteger> = TLargeInteger
export type Int168<TLargeInteger> = TLargeInteger
export type Int160<TLargeInteger> = TLargeInteger
export type Int152<TLargeInteger> = TLargeInteger
export type Int144<TLargeInteger> = TLargeInteger
export type Int136<TLargeInteger> = TLargeInteger
export type Int128<TLargeInteger> = TLargeInteger
export type Int120<TLargeInteger> = TLargeInteger
export type Int112<TLargeInteger> = TLargeInteger
export type Int104<TLargeInteger> = TLargeInteger
export type Int96<TLargeInteger> = TLargeInteger
export type Int88<TLargeInteger> = TLargeInteger
export type Int80<TLargeInteger> = TLargeInteger
export type Int72<TLargeInteger> = TLargeInteger
export type Int64<TLargeInteger> = TLargeInteger
export type Int56<TLargeInteger> = TLargeInteger
export type Int48<TLargeInteger> = TLargeInteger
export type Int40<TLargeInteger> = TLargeInteger
export type Int32 = number
export type Int24 = number
export type Int16 = number
export type Int8 = number
export type UInt256<TLargeInteger> = TLargeInteger
export type UInt248<TLargeInteger> = TLargeInteger
export type UInt240<TLargeInteger> = TLargeInteger
export type UInt232<TLargeInteger> = TLargeInteger
export type UInt224<TLargeInteger> = TLargeInteger
export type UInt216<TLargeInteger> = TLargeInteger
export type UInt208<TLargeInteger> = TLargeInteger
export type UInt200<TLargeInteger> = TLargeInteger
export type UInt192<TLargeInteger> = TLargeInteger
export type UInt184<TLargeInteger> = TLargeInteger
export type UInt176<TLargeInteger> = TLargeInteger
export type UInt168<TLargeInteger> = TLargeInteger
export type UInt160<TLargeInteger> = TLargeInteger
export type UInt152<TLargeInteger> = TLargeInteger
export type UInt144<TLargeInteger> = TLargeInteger
export type UInt136<TLargeInteger> = TLargeInteger
export type UInt128<TLargeInteger> = TLargeInteger
export type UInt120<TLargeInteger> = TLargeInteger
export type UInt112<TLargeInteger> = TLargeInteger
export type UInt104<TLargeInteger> = TLargeInteger
export type UInt96<TLargeInteger> = TLargeInteger
export type UInt88<TLargeInteger> = TLargeInteger
export type UInt80<TLargeInteger> = TLargeInteger
export type UInt72<TLargeInteger> = TLargeInteger
export type UInt64<TLargeInteger> = TLargeInteger
export type UInt56<TLargeInteger> = TLargeInteger
export type UInt48<TLargeInteger> = TLargeInteger
export type UInt40<TLargeInteger> = TLargeInteger
export type UInt32 = number
export type UInt24 = number
export type UInt16 = number
export type UInt8 = number
abstract class ByteArray extends Uint8Array {
	static fromByteArray<TConstructor extends typeof ByteArray & { new(): InstanceType<TConstructor> }>(this: TConstructor, bytes: Uint8Array | Array<number>, pad?: 'left' | 'right'): InstanceType<TConstructor> {
		let result = new this()
		// special case for variable sized types like `Bytes`
		if (result.length === 0) result = new this(bytes.length)
		if (bytes.length > result.length) throw new Error(`Source bytes are longer (${bytes.length}) than destination bytes ${result.length}\n${bytes}`)
		for (let byte of bytes) {
			if (byte > 0xff || byte < 0) throw new Error(`Source array must only include numbers between 0 and ${0xff}.\n${bytes}`)
		}
		result.set(bytes, (pad === 'left') ? result.length - bytes.length : 0)
		return result as InstanceType<TConstructor>
	}
	static fromHexString<TConstructor extends typeof ByteArray & { new(): InstanceType<TConstructor> }>(this: TConstructor, hex: string): InstanceType<TConstructor> {
		const match = new RegExp(`^(?:0x)?([a-fA-F0-9]*)$`).exec(hex)
		if (match === null) throw new Error(`Expected a hex string encoded byte array with an optional '0x' prefix but received ${hex}`)
		if (match.length % 2) throw new Error(`Hex string encoded byte array must be an even number of charcaters long.`)
		const normalized = match[1]
		const bytes = []
		for (let i = 0; i < normalized.length; i += 2) {
			bytes.push(Number.parseInt(`${normalized[i]}${normalized[i+1]}`, 16))
		}
		return this.fromByteArray(bytes)
	}
	static fromStringLiteral<TConstructor extends typeof ByteArray & { new(): InstanceType<TConstructor> }>(this: TConstructor, literal: string): InstanceType<TConstructor> {
		const encoded = createTextEncoder().encode(literal)
		return this.fromByteArray(encoded)

	}
	toString = () => this.reduce((result: string, byte: number) => result + ('0' + byte.toString(16)).slice(-2), '')
	to0xString = () => `0x${this.toString()}`
	equals = (other?: Uint8Array | null): boolean => {
		if (other === undefined || other === null) return false
		if (this.length !== other.length) return false
		for (let i = 0; i < this.length; ++i) {
			if (this[i] !== other[i]) return false
		}
		return true
	}
	static get [Symbol.species]() { return Uint8Array }
}
export class Bytes extends ByteArray { Bytes: unknown }
export class Bytes32 extends ByteArray { constructor() { super(32) }; Bytes32: unknown }
export class Bytes31 extends ByteArray { constructor() { super(31) }; Bytes31: unknown }
export class Bytes30 extends ByteArray { constructor() { super(30) }; Bytes30: unknown }
export class Bytes29 extends ByteArray { constructor() { super(29) }; Bytes29: unknown }
export class Bytes28 extends ByteArray { constructor() { super(28) }; Bytes28: unknown }
export class Bytes27 extends ByteArray { constructor() { super(27) }; Bytes27: unknown }
export class Bytes26 extends ByteArray { constructor() { super(26) }; Bytes26: unknown }
export class Bytes25 extends ByteArray { constructor() { super(25) }; Bytes25: unknown }
export class Bytes24 extends ByteArray { constructor() { super(24) }; Bytes24: unknown }
export class Bytes23 extends ByteArray { constructor() { super(23) }; Bytes23: unknown }
export class Bytes22 extends ByteArray { constructor() { super(22) }; Bytes22: unknown }
export class Bytes21 extends ByteArray { constructor() { super(21) }; Bytes21: unknown }
export class Bytes20 extends ByteArray { constructor() { super(20) }; Bytes20: unknown }
export class Bytes19 extends ByteArray { constructor() { super(19) }; Bytes19: unknown }
export class Bytes18 extends ByteArray { constructor() { super(18) }; Bytes18: unknown }
export class Bytes17 extends ByteArray { constructor() { super(17) }; Bytes17: unknown }
export class Bytes16 extends ByteArray { constructor() { super(16) }; Bytes16: unknown }
export class Bytes15 extends ByteArray { constructor() { super(15) }; Bytes15: unknown }
export class Bytes14 extends ByteArray { constructor() { super(14) }; Bytes14: unknown }
export class Bytes13 extends ByteArray { constructor() { super(13) }; Bytes13: unknown }
export class Bytes12 extends ByteArray { constructor() { super(12) }; Bytes12: unknown }
export class Bytes11 extends ByteArray { constructor() { super(11) }; Bytes11: unknown }
export class Bytes10 extends ByteArray { constructor() { super(10) }; Bytes10: unknown }
export class Bytes9 extends ByteArray { constructor() { super(9) }; Bytes9: unknown }
export class Bytes8 extends ByteArray { constructor() { super(8) }; Bytes8: unknown }
export class Bytes7 extends ByteArray { constructor() { super(7) }; Bytes7: unknown }
export class Bytes6 extends ByteArray { constructor() { super(6) }; Bytes6: unknown }
export class Bytes5 extends ByteArray { constructor() { super(5) }; Bytes5: unknown }
export class Bytes4 extends ByteArray { constructor() { super(4) }; Bytes4: unknown }
export class Bytes3 extends ByteArray { constructor() { super(3) }; Bytes3: unknown }
export class Bytes2 extends ByteArray { constructor() { super(2) }; Bytes2: unknown }
export class Bytes1 extends ByteArray { constructor() { super(1) }; Bytes1: unknown }
export class Address extends ByteArray { constructor() { super(20) }; Address: unknown }
export class SignatureHash extends ByteArray { constructor() { super(4) }; SignatureHash: unknown }
export type LargeSignedNumberLike<TLargeInteger> = Int256<TLargeInteger> | Int248<TLargeInteger> | Int240<TLargeInteger> | Int232<TLargeInteger> | Int224<TLargeInteger> | Int216<TLargeInteger> | Int208<TLargeInteger> | Int200<TLargeInteger> | Int192<TLargeInteger> | Int184<TLargeInteger> | Int176<TLargeInteger> | Int168<TLargeInteger> | Int160<TLargeInteger> | Int152<TLargeInteger> | Int144<TLargeInteger> | Int136<TLargeInteger> | Int128<TLargeInteger> | Int120<TLargeInteger> | Int112<TLargeInteger> | Int104<TLargeInteger> | Int96<TLargeInteger> | Int88<TLargeInteger> | Int80<TLargeInteger> | Int72<TLargeInteger> | Int64<TLargeInteger> | Int56<TLargeInteger> | Int48<TLargeInteger> | Int40<TLargeInteger>
export type LargeUnsignedNumberLike<TLargeInteger> = UInt256<TLargeInteger> | UInt248<TLargeInteger> | UInt240<TLargeInteger> | UInt232<TLargeInteger> | UInt224<TLargeInteger> | UInt216<TLargeInteger> | UInt208<TLargeInteger> | UInt200<TLargeInteger> | UInt192<TLargeInteger> | UInt184<TLargeInteger> | UInt176<TLargeInteger> | UInt168<TLargeInteger> | UInt160<TLargeInteger> | UInt152<TLargeInteger> | UInt144<TLargeInteger> | UInt136<TLargeInteger> | UInt128<TLargeInteger> | UInt120<TLargeInteger> | UInt112<TLargeInteger> | UInt104<TLargeInteger> | UInt96<TLargeInteger> | UInt88<TLargeInteger> | UInt80<TLargeInteger> | UInt72<TLargeInteger> | UInt64<TLargeInteger> | UInt56<TLargeInteger> | UInt48<TLargeInteger> | UInt40<TLargeInteger>
export type LargeNumberLike<TLargeInteger> = LargeSignedNumberLike<TLargeInteger> | LargeUnsignedNumberLike<TLargeInteger>
export type SmallSignedNumberLike = Int32 | Int24 | Int16 | Int8
export type SmallUnsignedNumberLike = UInt32 | UInt24 | UInt16 | UInt8
export type SmallNumberLike =  SmallSignedNumberLike | SmallUnsignedNumberLike
export type NumberLike<TLargeInteger> = LargeNumberLike<TLargeInteger> | SmallNumberLike
export type FixedBytesLike = Bytes32 | Bytes31 | Bytes30 | Bytes29 | Bytes28 | Bytes27 | Bytes26 | Bytes25 | Bytes24 | Bytes23 | Bytes22 | Bytes21 | Bytes20 | Bytes19 | Bytes18 | Bytes17 | Bytes16 | Bytes15 | Bytes14 | Bytes13 | Bytes12 | Bytes11 | Bytes10 | Bytes9 | Bytes8 | Bytes7 | Bytes6 | Bytes5 | Bytes4 | Bytes3 | Bytes2 | Bytes1
export type BytesLike = Bytes | FixedBytesLike | Address | SignatureHash
export type EncodablePrimitive<TLargeInteger> = NumberLike<TLargeInteger> | BytesLike | string | boolean
export type Encodable<TLargeInteger> = EncodablePrimitive<TLargeInteger> | EncodableTuple<TLargeInteger> | EncodableArray<TLargeInteger>
export interface EncodableTuple<TLargeInteger> {
	[x: string]: Encodable<TLargeInteger>
}
export interface EncodableArray<TLargeInteger> extends Array<Encodable<TLargeInteger>> {}

export interface Transaction<TLargeInteger> {
	to: Address
	data: Bytes
	value?: UInt256<TLargeInteger>
}

export interface TransactionReceipt {
	success: boolean
	events: Array<EncodedEvent>
}

export interface EncodedEvent {
	topics: Array<Bytes32>
	data: Bytes
}

export interface DecodedEvent<TLargeInteger> {
	name: string
	parameters: EncodableTuple<TLargeInteger>
}

export interface EventDescription {
	name: string
	signature: string
	parameters: Array<EventParameterDescription>
}

export interface EventParameterDescription extends ParameterDescription {
	indexed: boolean
}

export interface ParameterDescription {
	name: string
	type: string
	components?: Array<ParameterDescription>
}


export const eventDescriptions: { [signatureHash: string]: EventDescription } = {
	'fbdb8fdfd32e84835a750769f56aef848a42071cd44b719c3add9f069250f83b': {"name":"durian","signature":"durian()","parameters":[]}
}

export namespace Banana {
	export interface durian<TLargeInteger> extends DecodedEvent<TLargeInteger> {
		name: 'durian'
		parameters: {

		}
	}
}

export namespace Banana {
	export interface durian<TLargeInteger> extends DecodedEvent<TLargeInteger> {
		name: 'durian'
		parameters: {

		}
	}
}

export type Event<TLargeInteger> = DecodedEvent<TLargeInteger> | Banana.durian<TLargeInteger> | Banana.durian<TLargeInteger>


export interface Dependencies<TLargeInteger> {
	call(transaction: Transaction<TLargeInteger>): Promise<Uint8Array>
	submitTransaction(transaction: Transaction<TLargeInteger>): Promise<TransactionReceipt>
	isLargeInteger(x: any): x is TLargeInteger
	encodeLargeUnsignedInteger(x: TLargeInteger): Bytes32
	encodeLargeSignedInteger(x: TLargeInteger): Bytes32
	decodeLargeUnsignedInteger(data: Bytes32): TLargeInteger
	decodeLargeSignedInteger(data: Bytes32): TLargeInteger
}


/**
 * By convention, pure/view methods have a `_` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a local version and a remote version (distinguished by the trailing `_`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).
 */
export class Contract<TLargeInteger> {
	protected constructor(protected readonly dependencies: Dependencies<TLargeInteger>, public readonly address: Address) { }

	protected async localCall(signatureHash: SignatureHash, inputParameterDescriptions: Array<ParameterDescription>, outputParameterDescriptions: Array<ParameterDescription>, parameters: Array<any>, attachedEth?: UInt256<TLargeInteger>): Promise<EncodableTuple<TLargeInteger>> {
		const data = this.encodeMethod(signatureHash, inputParameterDescriptions, parameters)
		const transaction = Object.assign({ to: this.address, data: data }, attachedEth ? { value: attachedEth } : {})
		const result = await this.dependencies.call(transaction)
		return this.decodeParameters(outputParameterDescriptions, result)
	}

	protected async remoteCall(signatureHash: SignatureHash, inputParameterDescriptions: Array<ParameterDescription>, parameters: Array<any>, errorContext: { transactionName: string }, attachedEth?: UInt256<TLargeInteger>): Promise<Array<Event<TLargeInteger>>> {
		const data = this.encodeMethod(signatureHash, inputParameterDescriptions, parameters)
		const transaction = Object.assign({ to: this.address, data: data }, attachedEth ? { value: attachedEth } : {})
		const transactionReceipt = await this.dependencies.submitTransaction(transaction)
		if (!transactionReceipt.success) {
			throw new Error(`Remote call of ${errorContext.transactionName} failed: ${JSON.stringify(transactionReceipt)}`)
		}
		return this.decodeEvents(transactionReceipt.events)
	}

	private encodeMethod(signatureHash: SignatureHash, parameterDescriptions: Array<ParameterDescription>, parameters: Array<Encodable<TLargeInteger>>): Bytes {
		const parameterBytes = this.encodeParameters(parameterDescriptions, parameters)
		return concatenateBytes([signatureHash, parameterBytes])
	}

	private decodeEvents(encodedEvents: Array<EncodedEvent>): Array<Event<TLargeInteger>> {
		const decodedEvents: Array<DecodedEvent<TLargeInteger>> = []
		encodedEvents.forEach(encodedEvent => {
			const decodedEvent = this.tryDecodeEvent(encodedEvent)
			if (decodedEvent) decodedEvents.push(decodedEvent)
		})
		return decodedEvents as Array<Event<TLargeInteger>>
	}

	private tryDecodeEvent(encodedEvent: EncodedEvent): DecodedEvent<TLargeInteger> | null {
		const signatureHash = encodedEvent.topics[0]
		const eventDescription = eventDescriptions[signatureHash.toString()]
		if (!eventDescription) return null
		const parameters = this.decodeEventParameters(eventDescription.parameters, encodedEvent.topics, encodedEvent.data, { eventSignature: eventDescription.signature })
		return { name: eventDescription.name, parameters: parameters }
	}

	private stringifyParams(params: Array<ParameterDescription>): Array<string> {
		return params.map(param => {
			if (param.type === 'tuple') {
				if (!param.components) throw new Error(`Expected components when type is ${param.type}`)
				return `(${this.stringifyParams(param.components).join(',')})`
			} else if (param.type === 'tuple[]') {
				if (!param.components) throw new Error(`Expected components when type is ${param.type}`)
				return `(${this.stringifyParams(param.components).join(',')})[]`
			} else {
				return param.type
			}
		})
	}

	private decodeEventParameters(parameters: Array<EventParameterDescription>, topics: Array<Bytes32>, data: Bytes, errorContext: { eventSignature: string }): EncodableTuple<TLargeInteger> {
		const indexedTypesForDecoding = parameters.filter(parameter => parameter.indexed).map(this.getTypeForEventDecoding)
		const nonIndexedTypesForDecoding = parameters.filter(parameter => !parameter.indexed)
		const indexedData = concatenateBytes(topics.slice(1))
		const nonIndexedData = data
		const decodedIndexedParameters = this.decodeParameters(indexedTypesForDecoding, indexedData)
		if (!decodedIndexedParameters) throw new Error(`Failed to decode topics for event ${errorContext.eventSignature}.\n${indexedData}`)
		const decodedNonIndexedParameters = this.decodeParameters(nonIndexedTypesForDecoding, nonIndexedData)
		if (!decodedNonIndexedParameters) throw new Error(`Failed to decode data for event ${errorContext.eventSignature}.\n${nonIndexedData}`)
		return Object.assign({}, decodedIndexedParameters, decodedNonIndexedParameters)
	}

	private getTypeForEventDecoding(parameter: EventParameterDescription): EventParameterDescription {
		if (!parameter.indexed) return parameter
		if (parameter.type !== 'string'
			&& parameter.type !== 'bytes'
			// TODO: check to see if we need to collapse fixed size tuples or not
			&& !parameter.type.startsWith('tuple')
			// TODO: check to see if we need to collapse fixed length arrays here or not
			&& !parameter.type.endsWith('[]'))
			return parameter
		return Object.assign({}, parameter, { type: 'bytes32' })
	}


	// decoding

	public decodeParameters(descriptions: Array<ParameterDescription>, data: Uint8Array): EncodableTuple<TLargeInteger> {
		let offset = 0
		const decoded: EncodableTuple<TLargeInteger> = {}
		for (let description of descriptions) {
			const { result, consumed } = this.decodeParameter(description, data, offset)
			offset += consumed
			// it is possible that name is missing/null/empty string if there is only a single parameter, in which case we use the placeholder name 'result'
			decoded[description.name || 'result'] = result
		}
		return decoded
	}

	private decodeParameter(description: ParameterDescription, data: Uint8Array, offset: number): { result: Encodable<TLargeInteger>, consumed: number } {
		return this.tryDecodeFixedArray(description, data, offset)
			|| this.tryDecodeDynamicArray(description, data, offset)
			|| this.tryDecodeTuple(description, data, offset)
			|| this.tryDecodeDynamicBytes(description, data, offset)
			|| this.tryDecodeString(description, data, offset)
			|| this.tryDecodeBoolean(description, data, offset)
			|| this.tryDecodeSmallNumber(description, data, offset)
			|| this.tryDecodeLargeNumber(description, data, offset)
			|| this.tryDecodeAddress(description, data, offset)
			|| this.tryDecodeFixedBytes(description, data, offset)
			|| this.tryDecodeFixedPointNumber(description, data, offset)
			|| this.tryDecodeFunction(description, data, offset)
			|| function () { throw new Error(`Unsupported parameter type ${description.type}`) }()
	}

	private tryDecodeFixedArray(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableArray<TLargeInteger>, consumed: number } | null {
		const match = /^(.*)\[(\d+)\]$/.exec(description.type)
		if (match === null) return null
		const subdescription = Object.assign({}, description, { type: match[1] })
		const length = Number.parseInt(match[2], 10)
		if (isDynamic(subdescription)) {
			const pointer = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(offset, offset + 32)))
			const result: EncodableArray<TLargeInteger> = []
			let consumed = 0
			for (let i = 0; i < length; ++i) {
				const { result: itemResult, consumed: itemConsumed } = this.decodeParameter(subdescription, data.subarray(pointer), consumed)
				consumed += itemConsumed
				result.push(itemResult)
			}
			return { result, consumed }
		} else {
			const result: EncodableArray<TLargeInteger> = []
			let consumed = 0
			for (let i = 0; i < length; ++i) {
				const { result: itemResult, consumed: itemConsumed } = this.decodeParameter(subdescription, data, offset + consumed)
				consumed += itemConsumed
				result.push(itemResult)
			}
			return { result, consumed }
		}
	}

	private tryDecodeDynamicArray(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableArray<TLargeInteger>, consumed: number } | null {
		if (!description.type.endsWith('[]')) return null
		const subtype = description.type.substring(0, description.type.length - 2)
		const subdescription = Object.assign({}, description, { type: subtype })
		const pointer = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(offset, offset + 32)))
		const length = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(pointer, pointer + 32)))
		const result: EncodableArray<TLargeInteger> = []
		let consumed = 0
		for (let i = 0; i < length; ++i) {
			const { result: itemResult, consumed: itemConsumed } = this.decodeParameter(subdescription, data.subarray(pointer + 32), consumed)
			consumed += itemConsumed
			result.push(itemResult)
		}
		return { result, consumed }
	}

	private tryDecodeTuple(description: ParameterDescription, data: Uint8Array, offset: number): { result: EncodableTuple<TLargeInteger>, consumed: number } | null {
		if (description.type !== 'tuple') return null
		const result: EncodableTuple<TLargeInteger> = {}
		let consumed: number = 0
		if (description.components === undefined || description.components.length === 0) {
		} else if (anyIsDynamic(description.components)) {
			const pointer = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(offset, offset + 32)))
			for (let component of description.components) {
				const { result: componentResult, consumed: componentConsumed } = this.decodeParameter(component, data.subarray(pointer), consumed)
				consumed += componentConsumed
				result[component.name] = componentResult
			}
			// from the point of view of the caller, we only consumed 32 bytes (the pointer)
			consumed = 32
		} else {
			for (let component of description.components) {
				const { result: componentResult, consumed: componentConsumed } = this.decodeParameter(component, data, offset + consumed)
				consumed += componentConsumed
				result[component.name] = componentResult
			}
		}
		return { result, consumed }
	}

	private tryDecodeDynamicBytes(description: ParameterDescription, data: Uint8Array, offset: number): { result: Bytes, consumed: 32 } | null {
		if (description.type !== 'bytes') return null
		const pointer = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(offset, offset + 32)))
		const length = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(pointer, pointer + 32)))
		const bytes = Bytes.fromByteArray(data.subarray(pointer + 32, pointer + 32 + length))
		return { result: bytes, consumed: 32 }
	}

	private tryDecodeString(description: ParameterDescription, data: Uint8Array, offset: number): { result: string, consumed: 32 } | null {
		if (description.type !== 'string') return null
		const pointer = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(offset, offset + 32)))
		const length = decodeSmallInteger(Bytes32.fromByteArray(data.subarray(pointer, pointer + 32)))
		const bytes = Bytes.fromByteArray(data.subarray(pointer + 32, pointer + 32 + length))
		const decoded = createTextDecoder().decode(bytes)
		return { result: decoded, consumed: 32 }
	}

	private tryDecodeBoolean(description: ParameterDescription, data: Uint8Array, offset: number): { result: boolean, consumed: 32 } | null {
		if (description.type !== 'bool') return null
		const bytes = Bytes32.fromByteArray(data.subarray(offset, offset + 32))
		const decoded = decodeSmallInteger(bytes)
		return { result: !!decoded, consumed: 32 }
	}

	private tryDecodeSmallNumber(description: ParameterDescription, data: Uint8Array, offset: number): { result: SmallNumberLike, consumed: 32 } | null {
		const match = /^(u?)int(\d*)$/.exec(description.type)
		if (match === null) return null
		const size = Number.parseInt(match[2])
		if (size >= 40) return null
		const signed = !match[1]
		const bytes = Bytes32.fromByteArray(data.subarray(offset, offset + 32))
		const decoded = decodeSmallInteger(bytes)
		if (!signed && size === 8) return { result: decoded as UInt8, consumed: 32 }
		else if (!signed && size === 16) return { result: decoded as UInt16, consumed: 32 }
		else if (!signed && size === 24) return { result: decoded as UInt24, consumed: 32 }
		else if (!signed && size === 32) return { result: decoded as UInt32, consumed: 32 }
		else if (signed && size === 8) return { result: decoded as Int8, consumed: 32 }
		else if (signed && size === 16) return { result: decoded as Int16, consumed: 32 }
		else if (signed && size === 24) return { result: decoded as Int24, consumed: 32 }
		else if (signed && size === 32) return { result: decoded as Int32, consumed: 32 }
		else return null
	}

	private tryDecodeLargeNumber(description: ParameterDescription, data: Uint8Array, offset: number): { result: LargeNumberLike<TLargeInteger>, consumed: 32 } | null {
		const match = /^(u?)int(\d*)$/.exec(description.type)
		if (match === null) return null
		const size = Number.parseInt(match[2])
		if (size <= 32) return null
		const signed = !match[1]
		const bytes = Bytes32.fromByteArray(data.subarray(offset, offset + 32))
		const decoded = signed ? this.dependencies.decodeLargeSignedInteger(bytes) : this.dependencies.decodeLargeUnsignedInteger(bytes)
		if (!signed && size == 256) return { result: decoded as Int256<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 248) return { result: decoded as Int248<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 240) return { result: decoded as Int240<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 232) return { result: decoded as Int232<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 224) return { result: decoded as Int224<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 216) return { result: decoded as Int216<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 208) return { result: decoded as Int208<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 200) return { result: decoded as Int200<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 192) return { result: decoded as Int192<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 184) return { result: decoded as Int184<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 176) return { result: decoded as Int176<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 168) return { result: decoded as Int168<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 160) return { result: decoded as Int160<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 152) return { result: decoded as Int152<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 144) return { result: decoded as Int144<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 136) return { result: decoded as Int136<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 128) return { result: decoded as Int128<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 120) return { result: decoded as Int120<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 112) return { result: decoded as Int112<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 104) return { result: decoded as Int104<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 96) return { result: decoded as Int96<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 88) return { result: decoded as Int88<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 80) return { result: decoded as Int80<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 72) return { result: decoded as Int72<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 64) return { result: decoded as Int64<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 56) return { result: decoded as Int56<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 48) return { result: decoded as Int48<TLargeInteger>, consumed: 32 }
		else if (!signed && size == 40) return { result: decoded as Int40<TLargeInteger>, consumed: 32 }
		else if (signed && size == 256) return { result: decoded as UInt256<TLargeInteger>, consumed: 32 }
		else if (signed && size == 248) return { result: decoded as UInt248<TLargeInteger>, consumed: 32 }
		else if (signed && size == 240) return { result: decoded as UInt240<TLargeInteger>, consumed: 32 }
		else if (signed && size == 232) return { result: decoded as UInt232<TLargeInteger>, consumed: 32 }
		else if (signed && size == 224) return { result: decoded as UInt224<TLargeInteger>, consumed: 32 }
		else if (signed && size == 216) return { result: decoded as UInt216<TLargeInteger>, consumed: 32 }
		else if (signed && size == 208) return { result: decoded as UInt208<TLargeInteger>, consumed: 32 }
		else if (signed && size == 200) return { result: decoded as UInt200<TLargeInteger>, consumed: 32 }
		else if (signed && size == 192) return { result: decoded as UInt192<TLargeInteger>, consumed: 32 }
		else if (signed && size == 184) return { result: decoded as UInt184<TLargeInteger>, consumed: 32 }
		else if (signed && size == 176) return { result: decoded as UInt176<TLargeInteger>, consumed: 32 }
		else if (signed && size == 168) return { result: decoded as UInt168<TLargeInteger>, consumed: 32 }
		else if (signed && size == 160) return { result: decoded as UInt160<TLargeInteger>, consumed: 32 }
		else if (signed && size == 152) return { result: decoded as UInt152<TLargeInteger>, consumed: 32 }
		else if (signed && size == 144) return { result: decoded as UInt144<TLargeInteger>, consumed: 32 }
		else if (signed && size == 136) return { result: decoded as UInt136<TLargeInteger>, consumed: 32 }
		else if (signed && size == 128) return { result: decoded as UInt128<TLargeInteger>, consumed: 32 }
		else if (signed && size == 120) return { result: decoded as UInt120<TLargeInteger>, consumed: 32 }
		else if (signed && size == 112) return { result: decoded as UInt112<TLargeInteger>, consumed: 32 }
		else if (signed && size == 104) return { result: decoded as UInt104<TLargeInteger>, consumed: 32 }
		else if (signed && size == 96) return { result: decoded as UInt96<TLargeInteger>, consumed: 32 }
		else if (signed && size == 88) return { result: decoded as UInt88<TLargeInteger>, consumed: 32 }
		else if (signed && size == 80) return { result: decoded as UInt80<TLargeInteger>, consumed: 32 }
		else if (signed && size == 72) return { result: decoded as UInt72<TLargeInteger>, consumed: 32 }
		else if (signed && size == 64) return { result: decoded as UInt64<TLargeInteger>, consumed: 32 }
		else if (signed && size == 56) return { result: decoded as UInt56<TLargeInteger>, consumed: 32 }
		else if (signed && size == 48) return { result: decoded as UInt48<TLargeInteger>, consumed: 32 }
		else if (signed && size == 40) return { result: decoded as UInt40<TLargeInteger>, consumed: 32 }
		else return null
	}

	private tryDecodeAddress(description: ParameterDescription, data: Uint8Array, offset: number): { result: Address, consumed: 32 } | null {
		if (description.type !== 'address') return null
		return { result: Address.fromByteArray(data.subarray(offset + 12, offset + 32)), consumed: 32 }
	}

	private tryDecodeFixedBytes(description: ParameterDescription, data: Uint8Array, offset: number): { result: FixedBytesLike, consumed: 32} | null {
		const match = /^bytes(\d+)$/.exec(description.type)
		if (match === null) return null
		const size = Number.parseInt(match[1])
		const dataSubset = data.subarray(offset, offset + size)
		if (size == 32) return { result: Bytes32.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 31) return { result: Bytes31.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 30) return { result: Bytes30.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 29) return { result: Bytes29.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 28) return { result: Bytes28.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 27) return { result: Bytes27.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 26) return { result: Bytes26.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 25) return { result: Bytes25.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 24) return { result: Bytes24.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 23) return { result: Bytes23.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 22) return { result: Bytes22.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 21) return { result: Bytes21.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 20) return { result: Bytes20.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 19) return { result: Bytes19.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 18) return { result: Bytes18.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 17) return { result: Bytes17.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 16) return { result: Bytes16.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 15) return { result: Bytes15.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 14) return { result: Bytes14.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 13) return { result: Bytes13.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 12) return { result: Bytes12.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 11) return { result: Bytes11.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 10) return { result: Bytes10.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 9) return { result: Bytes9.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 8) return { result: Bytes8.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 7) return { result: Bytes7.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 6) return { result: Bytes6.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 5) return { result: Bytes5.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 4) return { result: Bytes4.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 3) return { result: Bytes3.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 2) return { result: Bytes2.fromByteArray(dataSubset), consumed: 32 }
		else if (size == 1) return { result: Bytes1.fromByteArray(dataSubset), consumed: 32 }
		return null
	}

	private tryDecodeFixedPointNumber(description: ParameterDescription, data: Uint8Array, offset: number): never | null {
		if (!/^u?fixed\d+x\d+$/.test(description.type)) return null
		throw new Error(`Encoding an EVM type ${description.type} is not supported`)
	}

	private tryDecodeFunction(description: ParameterDescription, data: Uint8Array, offset: number): never | null {
		if (description.type !== 'function') return null
		throw new Error(`Decoding an EVM type ${description.type} is not supported`)
	}


	// encoding

	public encodeParameters(descriptions: Array<ParameterDescription>, parameters: Array<Encodable<TLargeInteger>>): Bytes {
		if (descriptions.length !== parameters.length) throw new Error(`Number of provided parameters (${parameters.length}) does not match number of expected parameters (${descriptions.length})`)
		const encodedParameters = parameters.map((nestedParameter, index) => this.encodeParameter(descriptions[index], nestedParameter))
		return encodeDynamicData(encodedParameters)
	}

	private encodeParameter(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: boolean, bytes: Uint8Array } {
		return this.tryEncodeFixedArray(description, parameter)
			|| this.tryEncodeDynamicArray(description, parameter)
			|| this.tryEncodeTuple(description, parameter)
			|| this.tryEncodeDynamicBytes(description, parameter)
			|| this.tryEncodeString(description, parameter)
			|| this.tryEncodeBoolean(description, parameter)
			|| this.tryEncodeSmallNumber(description, parameter)
			|| this.tryEncodeLargeNumber(description, parameter)
			|| this.tryEncodeAddress(description, parameter)
			|| this.tryEncodeFixedBytes(description, parameter)
			|| this.tryEncodeFixedPointNumber(description)
			|| this.tryEncodeFunction(description)
			|| function () { throw new Error(`Unsupported parameter type ${description.type}`) }()
	}

	private tryEncodeFixedArray(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: boolean, bytes: Uint8Array } | null {
		const match = /^(.*)\[(\d+)\]$/.exec(description.type)
		if (match === null) return null
		const size = Number.parseInt(match[2])
		if (!Array.isArray(parameter) || parameter.length !== size) throw new Error(`Can only encode a JavaScript 'array' of length ${size} into an EVM 'array' of length ${size}\n${parameter}`)
		const nestedDescription = Object.assign({}, description, { type: match[1] })
		const encodedParameters = parameter.map(nestedParameter => this.encodeParameter(nestedDescription, nestedParameter))
		const isDynamic = encodedParameters.some(x => x.isDynamic)
		if (isDynamic) {
			return { isDynamic: isDynamic, bytes: encodeDynamicData(encodedParameters)}
		} else {
			return { isDynamic: isDynamic, bytes: concatenateBytes(encodedParameters.map(x => x.bytes)) }
		}
	}

	private tryEncodeDynamicArray(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: true, bytes: Uint8Array } | null {
		if (!description.type.endsWith('[]')) return null
		if (!Array.isArray(parameter)) throw new Error(`Can only encode a JavaScript 'array' into an EVM 'array'\n${parameter}`)
		const nestedDescription = Object.assign({}, description, { type: description.type.substring(0, description.type.length - 2) })
		const encodedParameters = parameter.map(nestedParameter => this.encodeParameter(nestedDescription, nestedParameter))
		const lengthBytes = numberToBytes32(encodedParameters.length)
		return { isDynamic: true, bytes: concatenateBytes([lengthBytes, encodeDynamicData(encodedParameters)]) }
	}

	private tryEncodeTuple(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: boolean, bytes: Uint8Array } | null {
		if (description.type !== 'tuple') return null
		if (typeof parameter !== 'object') throw new Error(`Can only encode a JavaScript 'object' into an EVM 'tuple'\n${parameter}`)
		if (description.components === undefined || description.components.length === 0) {
			return { isDynamic: false, bytes: new Bytes(0) }
		} else {
			const encodableTuple = parameter as EncodableTuple<TLargeInteger>
			const encodedComponents = description.components.map(component => this.encodeParameter(component, encodableTuple[component.name]))
			const isDynamic = encodedComponents.some(x => x.isDynamic)
			return { isDynamic: isDynamic, bytes: isDynamic ? encodeDynamicData(encodedComponents) : concatenateBytes(encodedComponents.map(x => x.bytes)) }
		}
	}

	private tryEncodeDynamicBytes(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: true, bytes: Uint8Array } | null {
		if (description.type !== 'bytes') return null
		if (!(parameter instanceof Uint8Array)) throw new Error(`Can only encode a JavaScript 'Uint8Array' into EVM 'bytes'\n${parameter}`)
		return { isDynamic: true, bytes: padAndLengthPrefix(parameter) }
	}

	private tryEncodeString(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: true, bytes: Uint8Array } | null {
		if (description.type !== 'string') return null
		if (typeof parameter !== 'string') throw new Error(`Can only encode a JavaScript 'string' into an EVM 'string'\n${parameter}`)
		const encoded = createTextEncoder().encode(parameter)
		return { isDynamic: true, bytes: padAndLengthPrefix(encoded) }
	}

	private tryEncodeBoolean(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
		if (description.type !== 'bool') return null
		if (typeof parameter !== 'boolean') throw new Error(`Can only encode JavaScript 'boolean' into EVM 'bool'\n${parameter}`)
		const result = new Bytes32()
		result.set([parameter ? 1 : 0], 31)
		return { isDynamic: false, bytes: result }
	}

	private tryEncodeSmallNumber(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
		const match = /^u?int(\d*)$/.exec(description.type)
		if (match === null) return null
		const size = Number.parseInt(match[1])
		if (size >= 40) return null
		if (typeof parameter !== 'number') throw new Error(`Can only encode a JavaScript 'number' into an EVM '${description.type}'\n${parameter}`)
		return { isDynamic: false, bytes: numberToBytes32(parameter) }
	}

	private tryEncodeLargeNumber(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
		const match = /^(u?)int(\d*)$/.exec(description.type)
		if (match === null) return null
		const size = Number.parseInt(match[2])
		if (size <= 32) return null
		const signed = !match[1]
		if (!this.dependencies.isLargeInteger(parameter)) throw new Error(`Can only encode a JavaScript 'TLargeInteger' into an EVM '${description.type}'\n${parameter}`)
		return { isDynamic: false, bytes: signed ? this.dependencies.encodeLargeSignedInteger(parameter) : this.dependencies.encodeLargeUnsignedInteger(parameter) }
	}

	private tryEncodeAddress(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
		if (description.type !== 'address') return null
		if (!(parameter instanceof Uint8Array) || parameter.length !== 20) throw new Error(`Can only encode JavaScript 'Uint8Array(20)' into EVM 'address'\n${parameter}`)
		return { isDynamic: false, bytes: padLeftTo32Bytes(parameter) }
	}

	private tryEncodeFixedBytes(description: ParameterDescription, parameter: Encodable<TLargeInteger>): { isDynamic: false, bytes: Uint8Array } | null {
		const match = /^bytes(\d+)$/.exec(description.type)
		if (match === null) return null
		const size = Number.parseInt(match[1])
		if (!(parameter instanceof Uint8Array) || parameter.length !== size) throw new Error(`Can only encode JavaScript 'Uint8Array(${size})' into EVM 'bytes${size}'\n${parameter}`)
		return { isDynamic: false, bytes: padRightTo32Bytes(parameter) }
	}

	private tryEncodeFixedPointNumber(description: ParameterDescription): { isDynamic: never, bytes: Uint8Array } | null {
		if (!/^u?fixed\d+x\d+$/.test(description.type)) return null
		throw new Error(`Encoding into EVM type ${description.type} is not supported`)
	}

	private tryEncodeFunction(description: ParameterDescription): { isDynamic: never, bytes: Uint8Array } | null {
		if (description.type !== 'function') return null
		throw new Error(`Encoding into EVM type ${description.type} is not supported`)
	}
}


export class Banana<TLargeInteger> extends Contract<TLargeInteger> {
	public constructor(dependencies: Dependencies<TLargeInteger>, address: Address) {
		super(dependencies, address)
	}

	public cherry = async (attachedEth?: UInt256<TLargeInteger>): Promise<Array<Event<TLargeInteger>>> => {
		const signatureHash = SignatureHash.fromByteArray([ 0xa2, 0x74, 0xc8, 0x6b ])
		const inputParameterDescriptions: Array<ParameterDescription> = []
		return await this.remoteCall(signatureHash, inputParameterDescriptions, [], { transactionName: 'cherry' }, attachedEth)
	}

	public cherry_ = async (attachedEth?: UInt256<TLargeInteger>): Promise<void> => {
		const signatureHash = SignatureHash.fromByteArray([ 0xa2, 0x74, 0xc8, 0x6b ])
		const inputParameterDescriptions: Array<ParameterDescription> = []
		const outputParameterDescriptions: Array<ParameterDescription> = []
		await this.localCall(signatureHash, inputParameterDescriptions, outputParameterDescriptions, [], attachedEth)
	}
}


// helpers

// TextEncoder/TextDecoder is in a different location in Browser vs NodeJS
const isBrowser = new Function("try {return this===window;}catch(e){ return false;}")
interface ITextEncoder { encode(input: string): Uint8Array }
interface ITextDecoder { decode(input: Uint8Array): string }
// browser
declare const TextEncoder: any, TextDecoder: any
// nodejs
let util: { TextEncoder: any, TextDecoder: any } = isBrowser() ? {} : require('util')
function createTextEncoder(): ITextEncoder { return isBrowser() ? new TextEncoder() : new util.TextEncoder() }
function createTextDecoder(): ITextDecoder { return isBrowser() ? new TextDecoder() : new util.TextDecoder() }

function encodeSmallInteger(x: number): Bytes32 {
	const negative = x < 0
	const stringified = ((negative ? 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff' : '0000000000000000000000000000000000000000000000000000000000000000') + (negative ? (2**32 - (x * -1)) : x).toString(16)).slice(-64)

	const result = new Bytes32()
	for (let i = 0; i < stringified.length; i += 2) {
		result[i/2] = Number.parseInt(stringified[i] + stringified[i+1], 16)
	}
	return result
}

function decodeSmallInteger(data: Bytes32): number {
	const negative = data[0] >= 0b10000000
	const bytes = Bytes4.fromByteArray(data.subarray(28, 32))
	const parsed = parseInt(bytes.to0xString())
	return negative ? parsed >> 0 : parsed
}

function padLeftTo32Bytes(input: Uint8Array): Bytes {
	const length = (input.length % 32)
		? input.length + 32 - input.length % 32
		: input.length
	const result = new Bytes(length)
	result.set(input, result.length - input.length)
	return result
}

function padRightTo32Bytes(input: Uint8Array): Bytes {
	const length = (input.length % 32)
		? input.length + 32 - input.length % 32
		: input.length
	const result = new Bytes(length)
	result.set(input, 0)
	return result
}

function concatenateBytes(source: Array<Uint8Array>): Bytes {
	const size = source.reduce((previous, current) => previous += current.byteLength, 0)
	const result = new Bytes(size)
	let offset = 0
	for (let array of source) {
		result.set(array, offset)
		offset += array.byteLength
	}
	return result
}

function numberToBytes32(source: number): Bytes32 {
	if (!Number.isSafeInteger(source)) throw new Error(`Cannot construct a Bytes32 from an unsafe integer like ${source}.`)
	return encodeSmallInteger(source)
}

function padAndLengthPrefix(source: Uint8Array): Bytes {
	const length = source.length
	const padded = padRightTo32Bytes(source)
	return concatenateBytes([numberToBytes32(length), padded])
}

function encodeDynamicData(encodedData: Array<{ isDynamic: boolean, bytes: Uint8Array }>): Bytes {
	let staticBytesSize = 0
	for (let encodedParameter of encodedData) {
		if (encodedParameter.isDynamic) staticBytesSize += 32
		else staticBytesSize += encodedParameter.bytes.length
	}
	const staticBytes: Array<Uint8Array> = []
	const dynamicBytes: Array<Uint8Array> = []
	for (let encodedParameter of encodedData) {
		if (encodedParameter.isDynamic) {
			const dynamicBytesAppendedSoFar = dynamicBytes.reduce((total, bytes) => total += bytes.length, 0)
			staticBytes.push(numberToBytes32(staticBytesSize + dynamicBytesAppendedSoFar))
			dynamicBytes.push(encodedParameter.bytes)
		} else {
			staticBytes.push(encodedParameter.bytes)
		}
	}
	return concatenateBytes([...staticBytes, ...dynamicBytes])
}

function anyIsDynamic(descriptions: Array<ParameterDescription>): boolean {
	for (let description of descriptions) {
		if (isDynamic(description)) return true
	}
	return false
}

function isDynamic(description: ParameterDescription): boolean {
	if (description.type === 'string') return true
	if (description.type === 'bytes') return true
	if (description.type.endsWith('[]')) return true
	const fixedArrayMatcher = /^(.*)\[(\d+)\]$/.exec(description.type)
	if (fixedArrayMatcher !== null && isDynamic(Object.assign({}, description, { type: fixedArrayMatcher[1] }))) return true
	if (description.type === 'tuple' && anyIsDynamic(description.components || [])) return true
	return false
}
